<!DOCTYPE html>
<html>
<meta charset="utf-8">
<head>
    <meta charset="utf-8">
    <title>I Love Big Data</title>
    <style>
      body { margin: 0; }

  .node circle {
    stroke: #3a403d;
    stroke-width: .5px;
  }
  </style>

    <!-- <script src="https://d3js.org/d3.v3.min.js"></script> -->
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/topojson.v1.min.js"></script>
    <script src="https://unpkg.com/cartogram-chart"></script>
    <script src="https://unpkg.com/d3-scale-chromatic"></script>
    <script type="text/javascript" src="dat.gui.js"></script>


</head>

<body>



<svg></svg>
<script>
        const width = 2000;
        const height = 600;
        const config = {
          speed: 0.005,
          verticalTilt: -30,
          horizontalTilt: 0
        }
        let locations = [];
        const svg = d3.select('svg')
            .attr('width', width).attr('height', height);
        const markerGroup = svg.append('g');
        const projection = d3.geoOrthographic();
        const initialScale = projection.scale();
        const path = d3.geoPath().projection(projection);
        const center = [width/3, height/2];
        var format = d3.format(",");
        var tip = d3.tip()
            .attr('class', 'd3-tip')
            .offset([-10, 0])
            .html(function(d) {
              return "<strong>Country: </strong><span class='details'>" + d.properties.name + "<br></span>" ;
            })

        svg.call(tip);

        drawGlobe();
        drawGraticule();
        enableRotation();



        function drawGlobe() {
            console.log('j1')
            d3.queue()
                .defer(d3.json, 'https://gist.githubusercontent.com/mbostock/4090846/raw/d534aba169207548a8a3d670c9c2cc719ff05c47/world-110m.json')
                .defer(d3.tsv, 'world_population.tsv')
                .await((error, worldData, locationData) => {



                    svg.selectAll(".segment")
                        .data(topojson.feature(worldData, worldData.objects.countries).features)
                        .enter().append("path")
                     <!--   .attr("class", "segment") -->
                        .attr("class", "countries")
                        .attr("d", path)
                        .style("stroke", "#888")
                        .style("stroke-width", "1px")
                        .style("fill", (d, i) => '#e5e5e5')
                        .style("opacity", ".6")
                        .on('mouseover',function(d){
                              tip.show(d);

                              d3.select(this)
                                .style("opacity", 1)
                                .style("stroke","white")
                                .style("stroke-width",3);
                            })
                        .on('mouseout', function(d){
                              tip.hide(d);

                              d3.select(this)
                                .style("opacity", 0.8)
                                .style("stroke","black")
                                .style("stroke-width",0.3);
                            });

                   <!--     locations = locationData; -->
                   <!--     drawMarkers(); -->
                        svg.on("click", function() {
                            var circle = svg.append('circle')
                                        .attr('cx', 1100)
                                        .attr('cy', 250)
                                        .attr('r', 50)
                                        .attr('fill', 'red');


                        })

                });

        }

        function drawGraticule() {
            const graticule = d3.geoGraticule()
                .step([10, 10]);

            svg.append("path")
                .datum(graticule)
                .attr("class", "graticule")
                .attr("d", path)
                .style("fill", "#fff")
                .style("stroke", "#ccc");
        }

        function enableRotation() {
            d3.timer(function (elapsed) {
                projection.rotate([config.speed * elapsed - 120, config.verticalTilt, config.horizontalTilt]);
                svg.selectAll("path").attr("d", path);
                drawMarkers();
            });
        }

        function drawMarkers() {
            const markers = markerGroup.selectAll('circle')
                .data(locations);

            markers
                .enter()
                .append('circle')
                .merge(markers)
                .attr('cx', d => projection([d.longitude, d.latitude])[0])
                .attr('cy', d => projection([d.longitude, d.latitude])[1])
                .attr('fill', d => {
                    const coordinate = [d.longitude, d.latitude];
                    gdistance = d3.geoDistance(coordinate, projection.invert(center));
                    return gdistance > 1.57 ? 'none' : 'steelblue';
                })
                .attr('r', 7);

            markerGroup.each(function () {
                this.parentNode.appendChild(this);
            });
        }
    </script>


<div id="world">
    <script>

    const gui = new dat.GUI();

    const colorScale = d3.scaleSequential(d3.interpolateYlOrBr);

    const cartogram = Cartogram()
            .valFormatter(n => n.toPrecision(3))
            (document.getElementById('world'));

    d3.json("ne_110m_admin_0_countries_top.json", function(error, world) {


    world.objects.ne_110m_admin_0_countries.geometries.splice(
                world.objects.ne_110m_admin_0_countries.geometries.findIndex(d => d.properties.ISO_A2 === 'AQ'),
                1
            );

    cartogram
        .topoJson(world)
        .topoObjectName('countries')
        .value(({ properties: { ISO_A2 } }) => ccData[ISO_A2])
        .color(({ properties: { ISO_A2 } }) => colorScale(ccData[ISO_A2]))
        .label(({ properties: p }) => `${p.NAME}`)
        .onClick(d => console.info(d));

    const controls = { 'Iterations': 1, 'Randomize': () => { genVals(); render(); }};
    gui.add(controls, 'Iterations', 1, 40).step(1).onChange(render);
    gui.add(controls, 'Randomize');

    genVals();
    render();

    //

    function genVals() {
        ccData = Object.assign(...world.objects.ne_110m_admin_0_countries.geometries
            .map(({ properties: { ISO_A2 } }) => ({ [ISO_A2]: Math.random() }))
        );
    }

    function render() {
        cartogram.iterations(controls.Iterations);

    }


     });
    </script>

</div>

<div id="world2">
    <h1>testing </h1>

    <script>
                sizeDivisor = 100, nodePadding = 2.5;
                var width2 = 100, height2= 100

                var svg = d3.select("#world2")
                    .append("svg")
                    .attr("width", width2)
                    .attr("height", height2);

                var color = d3.scaleOrdinal(["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"]);

                var simulation = d3.forceSimulation()
                    .force("forceX", d3.forceX().strength(.1).x(width2 * .5))
                    .force("forceY", d3.forceY().strength(.1).y(height2 * .5))
                    .force("center", d3.forceCenter().x(width * .5).y(height2 * .5))
                    .force("charge", d3.forceManyBody().strength(-15));

                d3.csv("data.csv", types, function(error,graph){
                  if (error) throw error;

                  // sort the nodes so that the bigger ones are at the back
                  graph = graph.sort(function(a,b){ return b.size - a.size; });

                  //update the simulation based on the data
                  simulation
                      .nodes(graph)
                      .force("collide", d3.forceCollide().strength(.5).radius(function(d){ return d.radius + nodePadding; }).iterations(1))
                      .on("tick", function(d){
                        node
                            .attr("cx", function(d){ return d.x; })
                            .attr("cy", function(d){ return d.y; })
                      });

                  var node = svg.append("g")
                      .attr("class", "node")
                    .selectAll("circle")
                    .data(graph)
                    .enter().append("circle")
                      .attr("r", function(d) { return d.radius; })
                      .attr("fill", function(d) { return color(d.continent); })
                      .attr("cx", function(d){ return d.x; })
                      .attr("cy", function(d){ return d.y; })
                      .call(d3.drag()
                          .on("start", dragstarted)
                          .on("drag", dragged)
                          .on("end", dragended));

                });

                function dragstarted(d) {
                  if (!d3.event.active) simulation.alphaTarget(.03).restart();
                  d.fx = d.x;
                  d.fy = d.y;
                }

                function dragged(d) {
                  d.fx = d3.event.x;
                  d.fy = d3.event.y;
                }

                function dragended(d) {
                  if (!d3.event.active) simulation.alphaTarget(.03);
                  d.fx = null;
                  d.fy = null;
                }

                function types(d){
                  d.gdp = +d.gdp;
                  d.size = +d.gdp / sizeDivisor;
                  d.size < 3 ? d.radius = 3 : d.radius = d.size;
                  return d;
                }
                </script>
</div>

</body>
</html>
