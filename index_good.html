<!DOCTYPE html>
<html>
<meta charset="utf-8">
<head>
    <meta charset="utf-8">
    <title>Food and Agriculture Organization of the United Nations Data Visualization</title>
    <style>

        .water {
          fill: #00248F;
        }

        .land {
          fill: #A98B6F;
          stroke: #FFF;
          stroke-width: 0.7px;
        }

        .land:hover {
          fill:#33CC33;
          stroke-width: 1px;
        }

        .focused {
          fill: #33CC33;
        }

        select {
          position: absolute;
          top: 20px;
          left: 580px;
          border: solid #ccc 1px;
          padding: 3px;
          box-shadow: inset 1px 1px 2px #ddd8dc;
        }

        .countryTooltip {
          position: absolute;
          display: none;
          pointer-events: none;
          background: #fff;
          padding: 5px;
          text-align: left;
          border: solid #ccc 1px;
          color: #666;
          font-size: 14px;
          font-family: sans-serif;
        }

        //line {
         // stroke: #9ecae1;
          //stroke-width: 1.5px;
        //}

        //.node {
          //pointer-events: all;
        //}

        //circle {
         // stroke: none;
          //stroke-width: 40px;
        //}

        .node circle {
          cursor: pointer;
          stroke: #3182bd;
          stroke-width: 1.5px;
        }

        .node text {
          font: 8px sans-serif;
          pointer-events: none;
          text-anchor: middle;
        }

        line.link {
          fill: none;
          stroke: #9ecae1;
          stroke-width: 5.5px;
        }

        .container1 {
          float: left;
        }

        .container2 {
          float: right;
        }


    </style>
    <style>
    #chart {
        font-family: "Helvetica Neue";
        margin-left: -20px;
        height: 506px;
    }

    .dot { stroke: #000; }

    .axis path, .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
    }

    .year.label {
        fill: #ddd;
    }

    .overlay {
        fill: none;
        pointer-events: all;
        cursor: ew-resize;
    }
      .d3-tip {
      font-family: "Helvetica Neue";
      line-height: 1;
      font-weight: bold;
      padding: 12px;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      border-radius: 2px;
      pointer-events: none;
    }

    /* Creates a small triangle extender for the tooltip */
    .d3-tip:after {
      box-sizing: border-box;
      display: inline;
      font-size: 10px;
      width: 100%;
      line-height: 1;
      color: rgba(0, 0, 0, 0.8);
      position: absolute;
      pointer-events: none;
    }

    /* Northward tooltips */
    .d3-tip.n:after {
      content: "\25BC";
      margin: -1px 0 0 0;
      top: 100%;
      left: 0;
      text-align: center;
    }

    /* Eastward tooltips */
    .d3-tip.e:after {
      content: "\25C0";
      margin: -4px 0 0 0;
      top: 50%;
      left: -8px;
    }

    /* Southward tooltips */
    .d3-tip.s:after {
      content: "\25B2";
      margin: 0 0 1px 0;
      top: -8px;
      left: 0;
      text-align: center;
    }

    /* Westward tooltips */
    .d3-tip.w:after {
      content: "\25B6";
      margin: -4px 0 0 -1px;
      top: 50%;
      left: 100%;
    }
</style>

    <!-- <script src="https://d3js.org/d3.v3.min.js"></script> -->

	<script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/topojson.v1.min.js"></script>
    <script src="https://unpkg.com/cartogram-chart"></script>
    <script src="https://unpkg.com/d3-scale-chromatic"></script>
    <script type="text/javascript" src="js/dat.gui.js"></script>
    <script src="js/d3-tip.js"></script>
    <script src="https://d3js.org/queue.v1.min.js"></script>
    <script src="https://d3js.org/d3-force.v2.min.js"></script>
    <script src="https://d3js.org/d3.v4.0.0-alpha.50.min.js"></script>

    <!-- jQuery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-tip/0.6.3/d3-tip.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-tip/0.7.1/d3-tip.min.js"></script>

    <h1>Food and Agriculture Organization of the United Nations Data Visualization</h1>
    <h2>Detailed Trade Matrix - Import / Export Quantity</h2>

</head>

<body>
	<div class="tab">
		<script src="http://d3js.org/d3.v3.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-tip/0.6.3/d3-tip.min.js"></script>

		<button class="tablinks" onclick="test(event, 'Overview')">Overview</button>

		<script src="https://d3js.org/d3.v4.min.js"></script>
		<button class="tablinks" onclick="global(event, 'Details')">Details</button>
	</div>
	<div id="Overview" class="tabcontent">
		<div id="cont" class="container-fluid text-center">
			<div id="chart" width="1380" height="1380"></div>

		</div>

	</div>

	<div id="Details" class="tabcontent" style="width:1770px">
		<svg width="500" height="600" id="svg1" style="background-color:white"></svg>
		<svg width="600" height="600" id="svg2" style="background-color:white">></svg>
		<svg width="600" height="600" id="svg3" style="background-color:white">></svg>
	</div>
	<!--<div style="width:1770px">

		<svg width="500" height="600" id="svg1" style="background-color:pink"></svg>
		<svg width="600" height="600" id="svg2" style="background-color:white">></svg>
		<svg width="600" height="600" id="svg3" style="background-color:white">></svg>
	</div> -->
  <!--<div class="container1" id="chart1">-->


	<script>
	function openCity(evt, cityName) {
	  var i, tabcontent, tablinks;

	  tabcontent = document.getElementsByClassName("tabcontent");
	  for (i = 0; i < tabcontent.length; i++) {
		tabcontent[i].style.display = "none";
	  }
	  tablinks = document.getElementsByClassName("tablinks");
	  for (i = 0; i < tablinks.length; i++) {
		tablinks[i].className = tablinks[i].className.replace(" active", "");
	  }
	  //document.getElementById(cityName).style.display = "block";
	  evt.currentTarget.className += " active";
	  if (cityName == 'overview') {
	  	test();
	  	} else if (cityName == 'details') {
		global();
	  }
	}

	function test() {
	   document.getElementById("chart").innerHTML='<object type="text/html" data="index_bubble.html" style="width:100%; height:100%;  border:none;" scrolling="no"  seamless="seamless" ></object>';
	}
    </script>
    <script>
    function global() {
      //var svgid = "#chart";

      //bubble(svgid);
      console.log('haha3');
      var width = 500,
      height = 600,
      sens = 0.25,
      focused;

      //Setting projection

      var projection = d3.geoOrthographic()
      .scale(245)
      .rotate([0, 0])
      .translate([width /2 , height/2 ])
      .clipAngle(90);

      var path = d3.geoPath()
      .projection(projection);

      //SVG container

      var svg = d3.select("#svg1").append("svg")
      .attr("width", width)
      .attr("height", height);

      //Adding water

      svg.append("path")
      .datum({type: "Sphere"})
      .attr("class", "water")
      .attr("d", path);

      var countryTooltip = d3.select("body").append("div").attr("class", "countryTooltip"),
      countryList = d3.select("body").append("select").attr("name", "countries");


      queue()
      .defer(d3.json, "https://gist.githubusercontent.com/mbostock/4090846/raw/d534aba169207548a8a3d670c9c2cc719ff05c47/world-110m.json")
      .defer(d3.tsv, "https://gist.githubusercontent.com/mbostock/4090846/raw/d534aba169207548a8a3d670c9c2cc719ff05c47/world-country-names.tsv")
      .await(ready);

      //Main function

      function showTree(c){
        var circle = svg.append('circle')
            .attr('cx', 1100)
            .attr('cy', 250)
            .attr('r', 50)
            .attr('fill', 'red');
      }

      function ready(error, world, countryData) {

        var countryById = {},
        countries = topojson.feature(world, world.objects.countries).features;

        //Adding countries to select

        countryData.forEach(function(d) {
          countryById[d.id] = d.name;

          option = countryList.append("option");
          option.text(d.name);
          option.property("value", d.id);
        });

        //Drawing countries on the globe

        var world = svg.selectAll("path.land")
        .data(countries)
        .enter().append("path")
        .attr("class", "land")
        .attr("d", path)

        //Drag event

        .call(d3.drag()
          .subject(function() { var r = projection.rotate(); return {x: r[0] / sens, y: -r[1] / sens}; })
          .on("drag", function() {
            var rotate = projection.rotate();
            projection.rotate([d3.event.x * sens, -d3.event.y * sens, rotate[2]]);
            svg.selectAll("path.land").attr("d", path);
            svg.selectAll(".focused").classed("focused", focused = false);
          }))

        //Mouse events

        .on("mouseover", function(d) {
          countryTooltip.text(countryById[d.id])
          .style("left", (d3.event.pageX + 7) + "px")
          .style("top", (d3.event.pageY - 15) + "px")
          .style("display", "block")
          .style("opacity", 1);
        })
        .on("mouseout", function(d) {
          countryTooltip.style("opacity", 0)
          .style("display", "none");
        })
        .on("mousemove", function(d) {
          countryTooltip.style("left", (d3.event.pageX + 7) + "px")
          .style("top", (d3.event.pageY - 15) + "px");
        })
        .on("click", function(d) {
          var countryname = countryById[d.id];
          var file1 ="graph.json";
          var file2 ="graph1.json";
          var mysvg1 = "#svg2";
          var mysvg2 ="#svg3";

          colla(countryname, file1, mysvg1);
          colla(countryname, file2, mysvg2);

        });


        //Country focus on option select

        d3.select("select").on("change", function() {
          var rotate = projection.rotate(),
            focusedCountry = country(countries, this),
            p = d3.geoCentroid(focusedCountry);
            console.log( focusedCountry)
          svg.selectAll(".focused").classed("focused", focused = false);

        //Globe rotating

          function transition() {
           d3.transition()
           .duration(2500)
           .tween("rotate", function() {
             var r = d3.interpolate(projection.rotate(), [-p[0], -p[1]]);
             return function(t) {
               projection.rotate(r(t));
               svg.selectAll("path").attr("d", path)
               .classed("focused", function(d, i) { return d.id == focusedCountry.id ? focused = d : false; });
             };
           });
           }
          function country(cnt, sel) {
             for(var i = 0, l = cnt.length; i < l; i++) {
             if(cnt[i].id == sel.value) {return cnt[i];}
             }
          }
          });
      }

      function colla(ctname, filename, svgname){

        d3.json(filename, function(error, json) {
            if (error) throw error;

            var width = 600,
            height = 600;
            for (i=0; i<json.length; i++) {
                console.log(json[i]['name'])
                if (json[i]['name']==ctname){
                    root1 = json[i];
                    break;
                } else {
                    root1 = 0
                    console.log('no country is selected')
                }
            }
            root = d3.hierarchy(root1);

            var i = 0;

            var transform = d3.zoomIdentity;;

            var nodeSvg, linkSvg, simulation, nodeEnter, linkEnter ;

            var svg2 = d3.select(svgname).append("svg")
                .attr("width", width)
                .attr("height", height)
                .call(d3.zoom().scaleExtent([1 / 2, 8]).on("zoom", zoomed))
              .append("g")
                .attr("transform", "translate(40,0)");

            function zoomed() {
              svg2.attr("transform", d3.event.transform);
            }

            simulation = d3.forceSimulation()
              .force("link", d3.forceLink().id(function(d) { return d.id; }))
              .force("charge", d3.forceManyBody())
              .force("link", d3.forceLink().distance(function(d){ return 250}))
              .force("center", d3.forceCenter(width / 2, height / 2))
              .on("tick", ticked);

            update();

            function update() {
              var nodes = flatten(root);
              var links = root.links();

              simulation
                .nodes(nodes)

              simulation.force("link")
                .links(links);

              simulation.restart();

              linkSvg = svg2.selectAll(".link")
                .data(links, function(d) { return d.target.id; })

              linkSvg.exit().remove();

              linkSvg = linkSvg.enter()
                  .append("line")
                  .attr("class", "link");

              link = svg2.selectAll(".link").data(links, function(d) { return d.target.id; })
              var linkEnter = link.enter().append("line").attr("class", "link");
              link = linkEnter.merge(link);


              nodeSvg = svg2.selectAll(".node")
                .data(nodes, function(d) { return d.id; }).style("fill", color);

              nodeSvg.exit().remove();

              nodeSvg = nodeSvg.enter()
                .append("g")
                  .attr("class", "node")
                  //.style("fill", color)
                  .attr("r", function(d) { return Math.sqrt(d.data.value) / 10 || 4.5; })
                  .on("click", click)
                  .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended))

                nodeSvg.append("circle")
                  .attr("r", function(d) { return Math.sqrt(d.data.value) / 10 || 4.5; })
                  .append("title")
                  .text(function(d) { return d.data.name; })

                nodeSvg.select("circle")
                  .style("fill", color);

                nodeSvg.append("text")
                  .attr("dy", ".35em")
                  //.attr("x", function(d) { return d.children ? -8 : 8; })
                  //.style("text-anchor", function(d) { return d.children ? "end" : "start"; })
                  .text(function(d) { return d.data.name; });



            }

            function ticked() {
              linkSvg
                  .attr("x1", function(d) { return d.source.x; })
                  .attr("y1", function(d) { return d.source.y; })
                  .attr("x2", function(d) { return d.target.x; })
                  .attr("y2", function(d) { return d.target.y; });

              nodeSvg
                  .attr("transform", function(d) { return "translate(" + d.x + ", " + d.y + ")"; });
            }

            // Color leaf nodes orange, and packages white or blue.
            function color(d) {
              return d._children ? "#3182bd" : d.children ? "#c6dbef" : "#fd8d3c";
            }

            function click(d) {
                if (!d3.event.defaultPrevented) {
                    if (d.children) {
                      d._children = d.children;
                      d.children = null;
                    } else {
                      d.children = d._children;
                      d._children = null;
                    }
                    update();
                  }
            }

            function dragstarted(d) {
              if (!d3.event.active) simulation.alphaTarget(0.3).restart()
              simulation.fix(d);
            }

            function dragged(d) {
              simulation.fix(d, d3.event.x, d3.event.y);
            }

            function dragended(d) {
              if (!d3.event.active) simulation.alphaTarget(0);
              simulation.unfix(d);
            }

            function flatten (root) {
              // hierarchical data to flat data for force layout
              var nodes = [], i = 0;
              function recurse(node) {
                if (node.children) node.children.forEach(recurse);
                if (!node.id) node.id = ++i;
                else ++i;
                nodes.push(node);
              }
              recurse(root);
              return nodes;
            }


        });

      }
      }
      </script>
	  <script>
	//Quick fix for resizing some things for mobile-ish viewers

	 function bubble() {
		var mobileScreen = ($( window ).innerWidth() < 500 ? true : false);
		//Scatterplot
		var margin = {left: 50, top: 20, right: 20, bottom: 20},	width = Math.min($("#chart").width(), 1380) - margin.left - margin.right,
			height = width*2/3;
		var svg = d3.select("#chart").append("svg")
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom)
		  .append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		// Various scales. These domains make assumptions of data, naturally.
		var xScale = d3.scale.linear().domain([0, 120000000]).range([0, width]),
			yScale = d3.scale.linear().domain([0, 160000000]).range([height, 0]),
			radiusScale = d3.scale.sqrt().domain([0, 5e8]).range([0, width * 0.05]),
			colorScale = d3.scale.category10();

		//var xScale = d3.scale.log().domain([300, 1e5]).range([0, width]),
		 //   yScale = d3.scale.linear().domain([10, 85]).range([height, 0]),
		  //  radiusScale = d3.scale.sqrt().domain([0, 5e8]).range([0, width * 0.05]),
		   // colorScale = d3.scale.category10();

		var formatX = d3.format(".1s");

		// The x & y axes.
		var xAxis = d3.svg.axis().scale(xScale).orient("bottom").tickFormat(function(d){return d/1000000 + "M"});
		//var xAxis = d3.svg.axis().scale(xScale).orient("bottom").ticks(8, formatX);
		var yAxis = d3.svg.axis().scale(yScale).orient("left").tickFormat(function(d){return d/1000000 + "M"});
		var format = d3.format(".2s");
		// Add the x-axis.
		svg.append("g")
			.attr("class", "x axis")
			.attr("transform", "translate(0," + height + ")")
			.call(xAxis);
		// Add the y-axis.
		svg.append("g")
			.attr("class", "y axis")
			.call(yAxis);
		// Add an x-axis label.
		svg.append("text")
			.attr("class", "x label")
			.attr("text-anchor", "end")
			.attr("x", width)
			.attr("y", height - 6)
			.text("import value, unit (1000 US$)");
		// Add a y-axis label.
		svg.append("text")
			.attr("class", "y label")
			.attr("text-anchor", "end")
			.attr("y", 6)
			.attr("dy", ".75em")
			.attr("transform", "rotate(-90)")
			.text("export value, unit (1000 US$)");
		// Add the year label; the value is set on transition.
		var label = svg.append("text")
			.attr("class", "year label")
			.attr("text-anchor", "end")
			.attr("y", height - 24)
			.attr("x", width)
				.attr("style", "font-size:" + (width * 0.2).toString() + "px")
			.text(2007);
		var tip = d3.tip()
		  .attr('class', 'd3-tip')
		  .direction('s')
		  .html(function(d) {
			return "<p><strong>" + d.name + "</strong></p><p><strong>Population: </strong>" + format(d.population) + "</p>";
		  })
		// Various accessors that specify the four dimensions of data to visualize.
		function x(d) { return d.income; }
		function y(d) { return d.lifeExpectancy; }
		function radius(d) { return d.population*10; }

		//function radius(d) { return 5;  }
		//function color(d) { return d.region; }
		function color(d) { return d.name; }
		function key(d) { return d.name; }
		// Load the data.
		d3.json("trade_exports_value.json", function(nations) {
			// A bisector since many nation's data is sparsely-defined.
			var bisect = d3.bisector(function(d) { return d[0]; });
			// Add a dot per nation. Initialize the data at 2007, and set the colors.
			console.log(nations)
			var dot = svg.append("g")
					.call(tip)
					.attr("class", "dots")
				.selectAll(".dot")
					.data(interpolateData(2007))
				.enter().append("circle")
					.on('mouseover', tip.show)
					.on('mouseout', tip.hide)
					.attr("class", function (d) { return "dot " + d.name; })
				.style("fill", function(d) { return colorScale(color(d)); })
				.call(position)
				.sort(order);
			console.log(nations);
			// Add an overlay for the year label.
			var box = label.node().getBBox();

			var overlay = svg.append("rect")
					.attr("class", "overlay")
					.attr("x", box.x)
					.attr("y", box.y)
					.attr("width", box.width)
					.attr("height", box.height)
					.on("mouseover", enableInteraction);

			// Start a transition that interpolates the data based on year.
			svg.transition()
				.duration(15000)
				.ease("linear")
				.tween("year", tweenYear)
				.each("end", enableInteraction);

			// Positions the dots based on data.
			function position(dot) {
				dot.attr("cx", function(d) {   return xScale(x(d)); })
					.attr("cy", function(d) {   return yScale(y(d)); })
					.attr("r", function(d) {  return radiusScale(radius(d)); });
					}

			// Defines a sort order so that the smallest dots are drawn on top.
			function order(a, b) { return radius(b) - radius(a); }

			// After the transition finishes, you can mouseover to change the year.
			function enableInteraction() {
				var yearScale = d3.scale.linear()
					.domain([2007, 2016])
					.range([box.x + 10, box.x + box.width - 10])
					.clamp(true);
				// Cancel the current transition, if any.
				svg.transition().duration(0);
				overlay
					.on("mouseover", mouseover)
					.on("mouseout", mouseout)
					.on("mousemove", mousemove)
					.on("touchmove", mousemove);
				function mouseover() { label.classed("active", true); }
				function mouseout() { label.classed("active", false); }
				function mousemove() { displayYear(yearScale.invert(d3.mouse(this)[0])); }
			}
			// Tweens the entire chart by first tweening the year, and then the data.
			// For the interpolated data, the dots and label are redrawn.
			function tweenYear() {
				var year = d3.interpolateNumber(2007, 2016);
				return function(t) { displayYear(year(t)); };
			}
			// Updates the display to show the specified year.
			function displayYear(year) {
				console.log(dot.data(interpolateData(year), key).call(position).sort(order))
				dot.data(interpolateData(year), key).call(position).sort(order);
				label.text(Math.round(year));
			}
			// Interpolates the dataset for the given (fractional) year.
			function interpolateData(year) {
				return nations.map(function(d) {
					return {
						name: d.name,
						//region: d.region,
						//income: interpolateValues(d.income, year),
						income: interpolateValues(d.importvalue, year),
						population: interpolateValues(d.population, year),
						//lifeExpectancy: interpolateValues(d.lifeExpectancy, year)
						lifeExpectancy: interpolateValues(d.exportvalue, year)
					};
				});
			}
			// Finds (and possibly interpolates) the value for the specified year.
			function interpolateValues(values, year) {
				var i = bisect.left(values, year, 0, values.length - 1),
					a = values[i];
				if (i > 0) {
					var b = values[i - 1],
						t = (year - a[0]) / (b[0] - a[0]);
					return a[1] * (1 - t) + b[1] * t;
				}
			  return a[1];
			}
		});
	}
	</script>
  <!--</div>
  <div class="container2" id="chart2">
  </div>-->






  </body>
</html>


